In the header file magic-band.h: I started by implementing the 6 structures related to the tape, queue, and stack. The first structure defines the nodes of the doubly linked list, having elements of char type from the tape and pointers to the next node and the previous one. The second structure is that of the tape/list, with a pointer to the finger position and to the sentinel (the sentinel always remains in the first position). The queue and stack are implemented through singly linked lists. For the queue, there are 2 structures, one for the commands that will be introduced in it, which contains a pointer to the next node and a char type array, and another for the queue itself, defined by pointers to the first and last node and its size. Similarly, the stack is defined by a structure that contains a pointer to the current finger position and a pointer to the next node, and the second structure, about the stack itself, contains its size and a pointer to the head of the stack (the last added element). Then I implemented the usual functions for each one. For the queue: the function to create a node, to create the queue (singly linked list), to check if it is empty, enqueue - adding a new node at the end (rear), dequeue - removing the first element from the queue, front - returns the first element from the queue and freeQueue - frees memory. For the stack: the function to create a node, to create the stack (singly linked list), to check if it is empty, push - adds a new node respecting the LIFO rule, top - returns the node from the top of the stack, pop - removes the last introduced element, respecting the LIFO rule and freeStack - frees memory. For the tape/doubly linked list: the function to create a node (createMagicNode), the list (createMagicTape) and freeMagicTape - frees memory. In the last part, I implemented the functions described by the instructions: move_left moves the finger one position to the left, except when it is in the first position (in which case it stays in place); move_right - moves the finger one position to the right, and if it is already on the last node, adds another one (which thus becomes the last node, in fact); move_left_char - searches, starting with the current finger position, for a character on the left side of the list, and if it reaches the first position and has not found it, returns ERROR; move_right_char - the same thing as move_left_char, but it will search on the right side of the list, and if it reaches the last position and has not found the character, adds a new node (#); write - returns the character the finger is pointing to; insert_left - adds a new node to the left of the current finger position (if the finger is in the first position, returns ERROR); insert_right - adds a new node to the right of the current finger position; show_current - prints the element the finger is on; show - prints the entire tape; undo - extracts the pointer from the top of the undo stack, adds the pointer to the current finger position in the redo stack and updates the finger position to point to the pointer extracted from the undo stack; redo - extracts the pointer from the top of the redo stack, adds the pointer to the current finger position in the undo stack and updates the finger position to point to the pointer extracted from the redo stack. Considering that the final result will be displayed in a .out file, all the functions that print (move_left_char, insert_left, show_current and show) have a FILE *out parameter.

In the magic-band.c file: I opened the tema1.in file with read-only rights. I read the content of this file using a matrix, basically scanning the first number - which represents the number of commands/lines in the matrix. Then I retained the content of each line in the form of columns in my initial matrix (instruction[MAX][MAX]). Each line is read until a newline is encountered. I closed the tema1.in file and opened the tema1.out file with write rights. Then I compared strings, specifically for each line in the file, I checked if the characters I had in the column in the instruction matrix matched the respective commands. To start with, I added the UPDATE type commands to the queue, executed the undo, redo, show and show_current commands directly, and started executing the UPDATE type commands at write. Initially, I extracted the string of characters from the beginning of the queue. Then I compared the string with the 7 UPDATE type commands and executed them, after which they were removed from the queue. In the end, I closed the tema1.out file and freed the memory.